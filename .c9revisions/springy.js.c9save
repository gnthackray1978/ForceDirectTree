{"ts":1360674841112,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * Springy v1.0.1\n *\n * Copyright (c) 2010 Dennis Hotson\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n//https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach\nif ( !Array.prototype.forEach ) {\n  Array.prototype.forEach = function( callback, thisArg ) {\n    var T, k;\n    if ( this == null ) {\n      throw new TypeError( \" this is null or not defined\" );\n    }\n    var O = Object(this);\n    var len = O.length >>> 0; // Hack to convert O.length to a UInt32\n    if ( {}.toString.call(callback) != \"[object Function]\" ) {\n      throw new TypeError( callback + \" is not a function\" );\n    }\n    if ( thisArg ) {\n      T = thisArg;\n    }\n    k = 0;\n    while( k < len ) {\n      var kValue;\n      if ( k in O ) {\n        kValue = O[ k ];\n        callback.call( T, kValue, k, O );\n      }\n      k++;\n    }\n  };\n}\n\n\nvar Node = function(id, data) {\n\tthis.id = id;\n\tthis.data = typeof(data) !== 'undefined' ? data : {};\n};\n\nvar Edge = function(id, source, target, data) {\n\tthis.id = id;\n\tthis.source = source;\n\tthis.target = target;\n\tthis.data = typeof(data) !== 'undefined' ? data : {};\n};\n\nvar Graph = function() {\n\tthis.nodeSet = {};\n\tthis.nodes = [];\n\tthis.edges = [];\n\tthis.adjacency = {};\n\n\tthis.nextNodeId = 0;\n\tthis.nextEdgeId = 0;\n\tthis.eventListeners = [];\n};\n\n\nGraph.prototype = {\n\n    addNode: function (node) {\n\t    if (typeof(this.nodeSet[node.id]) === 'undefined') {\n\t\t    this.nodes.push(node);\n\t    }\n\n\t    this.nodeSet[node.id] = node;\n\n\t    this.notify();\n\t    return node;\n    },\n    addEdge:function(edge) {\n\t    var exists = false;\n\t    this.edges.forEach(function(e) {\n\t\t    if (edge.id === e.id) { exists = true; }\n\t    });\n\n\t    if (!exists) {\n\t\t    this.edges.push(edge);\n\t    }\n\n\t    if (typeof(this.adjacency[edge.source.id]) === 'undefined') {\n\t\t    this.adjacency[edge.source.id] = {};\n\t    }\n\t    if (typeof(this.adjacency[edge.source.id][edge.target.id]) === 'undefined') {\n\t\t    this.adjacency[edge.source.id][edge.target.id] = [];\n\t    }\n\n\t    exists = false;\n\t    this.adjacency[edge.source.id][edge.target.id].forEach(function(e) {\n\t\t\t    if (edge.id === e.id) { exists = true; }\n\t    });\n\n\t    if (!exists) {\n\t\t    this.adjacency[edge.source.id][edge.target.id].push(edge);\n\t    }\n\n\t    this.notify();\n\t    return edge;\n    },\n    newNode: function(data) {\n\t    var node = new Node(this.nextNodeId++, data);\n\t    this.addNode(node);\n\t    return node;\n    },\n    newEdge: function(source, target, data) {\n\t    var edge = new Edge(this.nextEdgeId++, source, target, data);\n\t    this.addEdge(edge);\n\t    return edge;\n\t},\n\t// find the edges from node1 to node2\n    getEdges:function(node1, node2) {\n\t    if (typeof(this.adjacency[node1.id]) !== 'undefined'\n\t\t    && typeof(this.adjacency[node1.id][node2.id]) !== 'undefined') {\n\t\t    return this.adjacency[node1.id][node2.id];\n\t    }\n\t    return [];\n\t},\n\t// remove a node and it's associated edges from the graph\n    removeNode: function(node) {\n\t    if (typeof(this.nodeSet[node.id]) !== 'undefined') {\n\t\t    delete this.nodeSet[node.id];\n\t    }\n\n\t    for (var i = this.nodes.length - 1; i >= 0; i--) {\n\t\t    if (this.nodes[i].id === node.id) {\n\t\t\t    this.nodes.splice(i, 1);\n\t\t    }\n\t    }\n\t    this.detachNode(node);\n\t},\n\t// removes edges associated with a given node\n    detachNode:function(node) {\n\t    var tmpEdges = this.edges.slice();\n\t    tmpEdges.forEach(function(e) {\n\t\t    if (e.source.id === node.id || e.target.id === node.id) {\n\t\t\t    this.removeEdge(e);\n\t\t    }\n\t    }, this);\n\n\t    this.notify();\n\t},\n\t// remove a node and it's associated edges from the graph\n    removeEdge : function(edge) {\n\t    for (var i = this.edges.length - 1; i >= 0; i--) {\n\t\t    if (this.edges[i].id === edge.id) {\n\t\t\t    this.edges.splice(i, 1);\n\t\t    }\n\t    }\n\n\t    for (var x in this.adjacency) {\n\t\t    for (var y in this.adjacency[x]) {\n\t\t\t    var edges = this.adjacency[x][y];\n\n\t\t\t    for (var j=edges.length - 1; j>=0; j--) {\n\t\t\t\t    if (this.adjacency[x][y][j].id === edge.id) {\n\t\t\t\t\t    this.adjacency[x][y].splice(j, 1);\n\t\t\t\t    }\n\t\t\t    }\n\t\t    }\n\t    }\n\n\t    this.notify();\n    },\n    merge : function (data) {\n\n        /* Merge a list of nodes and edges into the current graph. eg.\n        var o = {\n\t        nodes: [\n\t\t        {id: 123, data: {type: 'user', userid: 123, displayname: 'aaa'}},\n\t\t        {id: 234, data: {type: 'user', userid: 234, displayname: 'bbb'}}\n\t        ],\n\t        edges: [\n\t\t        {from: 0, to: 1, type: 'submitted_design', directed: true, data: {weight: }}\n\t        ]\n        }\n        */\n\t    var nodes = [];\n\t    data.nodes.forEach(function(n) {\n\t\t    nodes.push(this.addNode(new Node(n.id, n.data)));\n\t    }, this);\n\n\t    data.edges.forEach(function(e) {\n\t\t    var from = nodes[e.from];\n\t\t    var to = nodes[e.to];\n\n\t\t    var id = (e.directed)\n\t\t\t    ? (id = e.type + \"-\" + from.id + \"-\" + to.id)\n\t\t\t    : (from.id < to.id) // normalise id for non-directed edges\n\t\t\t\t    ? e.type + \"-\" + from.id + \"-\" + to.id\n\t\t\t\t    : e.type + \"-\" + to.id + \"-\" + from.id;\n\n\t\t    var edge = this.addEdge(new Edge(id, from, to, e.data));\n\t\t    edge.data.type = e.type;\n\t    }, this);\n    },\n    filterNodes : function(fn) {\n\t    var tmpNodes = this.nodes.slice();\n\t    tmpNodes.forEach(function(n) {\n\t\t    if (!fn(n)) {\n\t\t\t    this.removeNode(n);\n\t\t    }\n\t    }, this);\n    },\n    filterEdges:function(fn) {\n\t    var tmpEdges = this.edges.slice();\n\t    tmpEdges.forEach(function(e) {\n\t\t    if (!fn(e)) {\n\t\t\t    this.removeEdge(e);\n\t\t    }\n\t    }, this);\n    },\n    addGraphListener :function(obj) {\n\t    this.eventListeners.push(obj);\n    },\n    notify :function() {\n\t    this.eventListeners.forEach(function(obj){\n\t\t    obj.graphChanged();\n\t    });\n    }\n\n}\n \n\n\n\n\n\n\n// -----------\nvar Layout = {};\n\nLayout.ForceDirected = function(graph, stiffness, repulsion, damping) {\n\tthis.graph = graph;\n\tthis.stiffness = stiffness; // spring stiffness constant\n\tthis.repulsion = repulsion; // repulsion constant\n\tthis.damping = damping; // velocity damping factor\n\n\tthis.nodePoints = {}; // keep track of points associated with nodes\n\tthis.edgeSprings = {}; // keep track of springs associated with edges\n};\n\n\n\n\n\n\n\nLayout.ForceDirected.prototype.point = function(node) {\n\tif (typeof(this.nodePoints[node.id]) === 'undefined') {\n\t\tvar mass = typeof(node.data.mass) !== 'undefined' ? node.data.mass : 1.0;\n\t\tthis.nodePoints[node.id] = new Layout.ForceDirected.Point(Vector.random(), mass);\n\t}\n\n\treturn this.nodePoints[node.id];\n};\n\nLayout.ForceDirected.prototype.spring = function(edge) {\n\tif (typeof(this.edgeSprings[edge.id]) === 'undefined') {\n\t\tvar length = typeof(edge.data.length) !== 'undefined' ? edge.data.length : 1.0;\n\n\t\tvar existingSpring = false;\n\n\t\tvar from = this.graph.getEdges(edge.source, edge.target);\n\t\tfrom.forEach(function(e) {\n\t\t\tif (existingSpring === false && typeof(this.edgeSprings[e.id]) !== 'undefined') {\n\t\t\t\texistingSpring = this.edgeSprings[e.id];\n\t\t\t}\n\t\t}, this);\n\n\t\tif (existingSpring !== false) {\n\t\t\treturn new Layout.ForceDirected.Spring(existingSpring.point1, existingSpring.point2, 0.0, 0.0);\n\t\t}\n\n\t\tvar to = this.graph.getEdges(edge.target, edge.source);\n\t\tfrom.forEach(function(e){\n\t\t\tif (existingSpring === false && typeof(this.edgeSprings[e.id]) !== 'undefined') {\n\t\t\t\texistingSpring = this.edgeSprings[e.id];\n\t\t\t}\n\t\t}, this);\n\n\t\tif (existingSpring !== false) {\n\t\t\treturn new Layout.ForceDirected.Spring(existingSpring.point2, existingSpring.point1, 0.0, 0.0);\n\t\t}\n\n\t\tthis.edgeSprings[edge.id] = new Layout.ForceDirected.Spring(\n\t\t\tthis.point(edge.source), this.point(edge.target), length, this.stiffness\n\t\t);\n\t}\n\n\treturn this.edgeSprings[edge.id];\n};\n\n// callback should accept two arguments: Node, Point\nLayout.ForceDirected.prototype.eachNode = function(callback) {\n\tvar t = this;\n\tthis.graph.nodes.forEach(function(n){\n\t\tcallback.call(t, n, t.point(n));\n\t});\n};\n\n// callback should accept two arguments: Edge, Spring\nLayout.ForceDirected.prototype.eachEdge = function(callback) {\n\tvar t = this;\n\tthis.graph.edges.forEach(function(e){\n\t\tcallback.call(t, e, t.spring(e));\n\t});\n};\n\n// callback should accept one argument: Spring\nLayout.ForceDirected.prototype.eachSpring = function(callback) {\n\tvar t = this;\n\tthis.graph.edges.forEach(function(e){\n\t\tcallback.call(t, t.spring(e));\n\t});\n};\n\n\n// Physics stuff\nLayout.ForceDirected.prototype.applyCoulombsLaw = function() {\n\tthis.eachNode(function(n1, point1) {\n\t\tthis.eachNode(function(n2, point2) {\n\t\t\tif (point1 !== point2)\n\t\t\t{\n\t\t\t\tvar d = point1.p.subtract(point2.p);\n\t\t\t\tvar distance = d.magnitude() + 0.1; // avoid massive forces at small distances (and divide by zero)\n\t\t\t\tvar direction = d.normalise();\n\n\t\t\t\t// apply force to each end point\n\t\t\t\tpoint1.applyForce(direction.multiply(this.repulsion).divide(distance * distance * 0.5));\n\t\t\t\tpoint2.applyForce(direction.multiply(this.repulsion).divide(distance * distance * -0.5));\n\t\t\t}\n\t\t});\n\t});\n};\n\nLayout.ForceDirected.prototype.applyHookesLaw = function() {\n\tthis.eachSpring(function(spring){\n\t\tvar d = spring.point2.p.subtract(spring.point1.p); // the direction of the spring\n\t\tvar displacement = spring.length - d.magnitude();\n\t\tvar direction = d.normalise();\n\n\t\t// apply force to each end point\n\t\tspring.point1.applyForce(direction.multiply(spring.k * displacement * -0.5));\n\t\tspring.point2.applyForce(direction.multiply(spring.k * displacement * 0.5));\n\t});\n};\n\nLayout.ForceDirected.prototype.attractToCentre = function() {\n\tthis.eachNode(function(node, point) {\n\t\tvar direction = point.p.multiply(-1.0);\n\t\tpoint.applyForce(direction.multiply(this.repulsion / 50.0));\n\t});\n};\n\n\nLayout.ForceDirected.prototype.updateVelocity = function(timestep) {\n\tthis.eachNode(function(node, point) {\n\t\t// Is this, along with updatePosition below, the only places that your\n\t\t// integration code exist?\n\t\tpoint.v = point.v.add(point.a.multiply(timestep)).multiply(this.damping);\n\t\tpoint.a = new Vector(0,0);\n\t});\n};\n\nLayout.ForceDirected.prototype.updatePosition = function(timestep) {\n\tthis.eachNode(function(node, point) {\n\t\t// Same question as above; along with updateVelocity, is this all of\n\t\t// your integration code?\n\t\tpoint.p = point.p.add(point.v.multiply(timestep));\n\t});\n};\n\n// Calculate the total kinetic energy of the system\nLayout.ForceDirected.prototype.totalEnergy = function(timestep) {\n\tvar energy = 0.0;\n\tthis.eachNode(function(node, point) {\n\t\tvar speed = point.v.magnitude();\n\t\tenergy += 0.5 * point.m * speed * speed;\n\t});\n\n\treturn energy;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; }; // stolen from coffeescript, thanks jashkenas! ;-)\n\nLayout.requestAnimationFrame = __bind(window.requestAnimationFrame ||\n\twindow.webkitRequestAnimationFrame ||\n\twindow.mozRequestAnimationFrame ||\n\twindow.oRequestAnimationFrame ||\n\twindow.msRequestAnimationFrame ||\n\tfunction(callback, element) {\n\t\twindow.setTimeout(callback, 10);\n\t}, window);\n\n\n// start simulation\nLayout.ForceDirected.prototype.start = function(interval, render, done) {\n\tvar t = this;\n\n\tif (this._started) return;\n\tthis._started = true;\n\n\tLayout.requestAnimationFrame(function step() {\n\t\tt.applyCoulombsLaw();\n\t\tt.applyHookesLaw();\n\t\tt.attractToCentre();\n\t\tt.updateVelocity(0.03);\n\t\tt.updatePosition(0.03);\n\n\t\tif (typeof(render) !== 'undefined')\n\t\t\trender();\n\n\t\t// stop simulation when energy of the system goes below a threshold\n\t\tif (t.totalEnergy() < 0.01) {\n\t\t\tt._started = false;\n\t\t\tif (typeof(done) !== 'undefined') { done(); }\n\t\t} else {\n            \n            Layout.requestAnimationFrame(step);\n\n\t\t}\n\t});\n};\n\n// Find the nearest point to a particular position\nLayout.ForceDirected.prototype.nearest = function (pos) {\n\n    var min = { node: null, point: null, distance: 1 };\n    var t = this;\n    this.graph.nodes.forEach(function (n) {\n        var point = t.point(n);\n        var distance = point.p.subtract(pos).magnitude();\n\n        if (min.distance === null || distance < min.distance) {\n            min = { node: n, point: point, distance: distance };\n        }\n    });\n\n  \n\n    return min;\n};\n\n// returns [bottomleft, topright]\nLayout.ForceDirected.prototype.getBoundingBox = function() {\n\tvar bottomleft = new Vector(-2,-2);\n\tvar topright = new Vector(2,2);\n\n\tthis.eachNode(function(n, point) {\n\t\tif (point.p.x < bottomleft.x) {\n\t\t\tbottomleft.x = point.p.x;\n\t\t}\n\t\tif (point.p.y < bottomleft.y) {\n\t\t\tbottomleft.y = point.p.y;\n\t\t}\n\t\tif (point.p.x > topright.x) {\n\t\t\ttopright.x = point.p.x;\n\t\t}\n\t\tif (point.p.y > topright.y) {\n\t\t\ttopright.y = point.p.y;\n\t\t}\n\t});\n\n\tvar padding = topright.subtract(bottomleft).multiply(0.07); // ~5% padding\n\n\treturn {bottomleft: bottomleft.subtract(padding), topright: topright.add(padding)};\n};\n\n\n\n\n// Vector\nVector = function(x, y) {\n\tthis.x = x;\n\tthis.y = y;\n};\n\nVector.random = function() {\n\treturn new Vector(10.0 * (Math.random() - 0.5), 10.0 * (Math.random() - 0.5));\n};\n\nVector.prototype.add = function(v2) {\n\treturn new Vector(this.x + v2.x, this.y + v2.y);\n};\n\nVector.prototype.subtract = function(v2) {\n\treturn new Vector(this.x - v2.x, this.y - v2.y);\n};\n\nVector.prototype.multiply = function(n) {\n\treturn new Vector(this.x * n, this.y * n);\n};\n\nVector.prototype.divide = function(n) {\n\treturn new Vector((this.x / n) || 0, (this.y / n) || 0); // Avoid divide by zero errors..\n};\n\nVector.prototype.magnitude = function() {\n\treturn Math.sqrt(this.x*this.x + this.y*this.y);\n};\n\nVector.prototype.normal = function() {\n\treturn new Vector(-this.y, this.x);\n};\n\nVector.prototype.normalise = function() {\n\treturn this.divide(this.magnitude());\n};\n\n\n\n\n\n\n\n// Point\nLayout.ForceDirected.Point = function(position, mass) {\n\tthis.p = position; // position\n\tthis.m = mass; // mass\n\tthis.v = new Vector(0, 0); // velocity\n\tthis.a = new Vector(0, 0); // acceleration\n};\n\nLayout.ForceDirected.Point.prototype.applyForce = function(force) {\n\tthis.a = this.a.add(force.divide(this.m));\n};\n\n// Spring\nLayout.ForceDirected.Spring = function(point1, point2, length, k) {\n\tthis.point1 = point1;\n\tthis.point2 = point2;\n\tthis.length = length; // spring length at rest\n\tthis.k = k; // spring constant (See Hooke's law) .. how stiff the spring is\n};\n\n\n\n\n\n\n\n\n\n// Layout.ForceDirected.Spring.prototype.distanceToPoint = function(point)\n// {\n// \t// hardcore vector arithmetic.. ohh yeah!\n// \t// .. see http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment/865080#865080\n// \tvar n = this.point2.p.subtract(this.point1.p).normalise().normal();\n// \tvar ac = point.p.subtract(this.point1.p);\n// \treturn Math.abs(ac.x * n.x + ac.y * n.y);\n// };\n\n// Renderer handles the layout rendering loop\nfunction Renderer(interval, layout, clear, drawEdge, drawNode) {\n\tthis.interval = interval;\n\tthis.layout = layout;\n\tthis.clear = clear;\n\tthis.drawEdge = drawEdge;\n\tthis.drawNode = drawNode;\n\n\tthis.layout.graph.addGraphListener(this);\n}\n\nRenderer.prototype.graphChanged = function(e) {\n\tthis.start();\n};\n\nRenderer.prototype.start = function() {\n\tvar t = this;\n\tthis.layout.start(1, function render() {\n\t\tt.clear();\n\n\t\tt.layout.eachEdge(function(edge, spring) {\n\t\t\tt.drawEdge(edge, spring.point1.p, spring.point2.p);\n\t\t});\n\n\t\tt.layout.eachNode(function(node, point) {\n\t\t\tt.drawNode(node, point.p);\n\t\t});\n\t});\n};\n\n"]],"start1":0,"start2":0,"length1":0,"length2":16208}]],"length":16208}
