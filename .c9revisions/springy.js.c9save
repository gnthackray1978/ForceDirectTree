{"ts":1360674841112,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * Springy v1.0.1\n *\n * Copyright (c) 2010 Dennis Hotson\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n//https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach\nif ( !Array.prototype.forEach ) {\n  Array.prototype.forEach = function( callback, thisArg ) {\n    var T, k;\n    if ( this == null ) {\n      throw new TypeError( \" this is null or not defined\" );\n    }\n    var O = Object(this);\n    var len = O.length >>> 0; // Hack to convert O.length to a UInt32\n    if ( {}.toString.call(callback) != \"[object Function]\" ) {\n      throw new TypeError( callback + \" is not a function\" );\n    }\n    if ( thisArg ) {\n      T = thisArg;\n    }\n    k = 0;\n    while( k < len ) {\n      var kValue;\n      if ( k in O ) {\n        kValue = O[ k ];\n        callback.call( T, kValue, k, O );\n      }\n      k++;\n    }\n  };\n}\n\n\nvar Node = function(id, data) {\n\tthis.id = id;\n\tthis.data = typeof(data) !== 'undefined' ? data : {};\n};\n\nvar Edge = function(id, source, target, data) {\n\tthis.id = id;\n\tthis.source = source;\n\tthis.target = target;\n\tthis.data = typeof(data) !== 'undefined' ? data : {};\n};\n\nvar Graph = function() {\n\tthis.nodeSet = {};\n\tthis.nodes = [];\n\tthis.edges = [];\n\tthis.adjacency = {};\n\n\tthis.nextNodeId = 0;\n\tthis.nextEdgeId = 0;\n\tthis.eventListeners = [];\n};\n\n\nGraph.prototype = {\n\n    addNode: function (node) {\n\t    if (typeof(this.nodeSet[node.id]) === 'undefined') {\n\t\t    this.nodes.push(node);\n\t    }\n\n\t    this.nodeSet[node.id] = node;\n\n\t    this.notify();\n\t    return node;\n    },\n    addEdge:function(edge) {\n\t    var exists = false;\n\t    this.edges.forEach(function(e) {\n\t\t    if (edge.id === e.id) { exists = true; }\n\t    });\n\n\t    if (!exists) {\n\t\t    this.edges.push(edge);\n\t    }\n\n\t    if (typeof(this.adjacency[edge.source.id]) === 'undefined') {\n\t\t    this.adjacency[edge.source.id] = {};\n\t    }\n\t    if (typeof(this.adjacency[edge.source.id][edge.target.id]) === 'undefined') {\n\t\t    this.adjacency[edge.source.id][edge.target.id] = [];\n\t    }\n\n\t    exists = false;\n\t    this.adjacency[edge.source.id][edge.target.id].forEach(function(e) {\n\t\t\t    if (edge.id === e.id) { exists = true; }\n\t    });\n\n\t    if (!exists) {\n\t\t    this.adjacency[edge.source.id][edge.target.id].push(edge);\n\t    }\n\n\t    this.notify();\n\t    return edge;\n    },\n    newNode: function(data) {\n\t    var node = new Node(this.nextNodeId++, data);\n\t    this.addNode(node);\n\t    return node;\n    },\n    newEdge: function(source, target, data) {\n\t    var edge = new Edge(this.nextEdgeId++, source, target, data);\n\t    this.addEdge(edge);\n\t    return edge;\n\t},\n\t// find the edges from node1 to node2\n    getEdges:function(node1, node2) {\n\t    if (typeof(this.adjacency[node1.id]) !== 'undefined'\n\t\t    && typeof(this.adjacency[node1.id][node2.id]) !== 'undefined') {\n\t\t    return this.adjacency[node1.id][node2.id];\n\t    }\n\t    return [];\n\t},\n\t// remove a node and it's associated edges from the graph\n    removeNode: function(node) {\n\t    if (typeof(this.nodeSet[node.id]) !== 'undefined') {\n\t\t    delete this.nodeSet[node.id];\n\t    }\n\n\t    for (var i = this.nodes.length - 1; i >= 0; i--) {\n\t\t    if (this.nodes[i].id === node.id) {\n\t\t\t    this.nodes.splice(i, 1);\n\t\t    }\n\t    }\n\t    this.detachNode(node);\n\t},\n\t// removes edges associated with a given node\n    detachNode:function(node) {\n\t    var tmpEdges = this.edges.slice();\n\t    tmpEdges.forEach(function(e) {\n\t\t    if (e.source.id === node.id || e.target.id === node.id) {\n\t\t\t    this.removeEdge(e);\n\t\t    }\n\t    }, this);\n\n\t    this.notify();\n\t},\n\t// remove a node and it's associated edges from the graph\n    removeEdge : function(edge) {\n\t    for (var i = this.edges.length - 1; i >= 0; i--) {\n\t\t    if (this.edges[i].id === edge.id) {\n\t\t\t    this.edges.splice(i, 1);\n\t\t    }\n\t    }\n\n\t    for (var x in this.adjacency) {\n\t\t    for (var y in this.adjacency[x]) {\n\t\t\t    var edges = this.adjacency[x][y];\n\n\t\t\t    for (var j=edges.length - 1; j>=0; j--) {\n\t\t\t\t    if (this.adjacency[x][y][j].id === edge.id) {\n\t\t\t\t\t    this.adjacency[x][y].splice(j, 1);\n\t\t\t\t    }\n\t\t\t    }\n\t\t    }\n\t    }\n\n\t    this.notify();\n    },\n    merge : function (data) {\n\n        /* Merge a list of nodes and edges into the current graph. eg.\n        var o = {\n\t        nodes: [\n\t\t        {id: 123, data: {type: 'user', userid: 123, displayname: 'aaa'}},\n\t\t        {id: 234, data: {type: 'user', userid: 234, displayname: 'bbb'}}\n\t        ],\n\t        edges: [\n\t\t        {from: 0, to: 1, type: 'submitted_design', directed: true, data: {weight: }}\n\t        ]\n        }\n        */\n\t    var nodes = [];\n\t    data.nodes.forEach(function(n) {\n\t\t    nodes.push(this.addNode(new Node(n.id, n.data)));\n\t    }, this);\n\n\t    data.edges.forEach(function(e) {\n\t\t    var from = nodes[e.from];\n\t\t    var to = nodes[e.to];\n\n\t\t    var id = (e.directed)\n\t\t\t    ? (id = e.type + \"-\" + from.id + \"-\" + to.id)\n\t\t\t    : (from.id < to.id) // normalise id for non-directed edges\n\t\t\t\t    ? e.type + \"-\" + from.id + \"-\" + to.id\n\t\t\t\t    : e.type + \"-\" + to.id + \"-\" + from.id;\n\n\t\t    var edge = this.addEdge(new Edge(id, from, to, e.data));\n\t\t    edge.data.type = e.type;\n\t    }, this);\n    },\n    filterNodes : function(fn) {\n\t    var tmpNodes = this.nodes.slice();\n\t    tmpNodes.forEach(function(n) {\n\t\t    if (!fn(n)) {\n\t\t\t    this.removeNode(n);\n\t\t    }\n\t    }, this);\n    },\n    filterEdges:function(fn) {\n\t    var tmpEdges = this.edges.slice();\n\t    tmpEdges.forEach(function(e) {\n\t\t    if (!fn(e)) {\n\t\t\t    this.removeEdge(e);\n\t\t    }\n\t    }, this);\n    },\n    addGraphListener :function(obj) {\n\t    this.eventListeners.push(obj);\n    },\n    notify :function() {\n\t    this.eventListeners.forEach(function(obj){\n\t\t    obj.graphChanged();\n\t    });\n    }\n\n}\n \n\n\n\n\n\n\n// -----------\nvar Layout = {};\n\nLayout.ForceDirected = function(graph, stiffness, repulsion, damping) {\n\tthis.graph = graph;\n\tthis.stiffness = stiffness; // spring stiffness constant\n\tthis.repulsion = repulsion; // repulsion constant\n\tthis.damping = damping; // velocity damping factor\n\n\tthis.nodePoints = {}; // keep track of points associated with nodes\n\tthis.edgeSprings = {}; // keep track of springs associated with edges\n};\n\n\n\n\n\n\n\nLayout.ForceDirected.prototype.point = function(node) {\n\tif (typeof(this.nodePoints[node.id]) === 'undefined') {\n\t\tvar mass = typeof(node.data.mass) !== 'undefined' ? node.data.mass : 1.0;\n\t\tthis.nodePoints[node.id] = new Layout.ForceDirected.Point(Vector.random(), mass);\n\t}\n\n\treturn this.nodePoints[node.id];\n};\n\nLayout.ForceDirected.prototype.spring = function(edge) {\n\tif (typeof(this.edgeSprings[edge.id]) === 'undefined') {\n\t\tvar length = typeof(edge.data.length) !== 'undefined' ? edge.data.length : 1.0;\n\n\t\tvar existingSpring = false;\n\n\t\tvar from = this.graph.getEdges(edge.source, edge.target);\n\t\tfrom.forEach(function(e) {\n\t\t\tif (existingSpring === false && typeof(this.edgeSprings[e.id]) !== 'undefined') {\n\t\t\t\texistingSpring = this.edgeSprings[e.id];\n\t\t\t}\n\t\t}, this);\n\n\t\tif (existingSpring !== false) {\n\t\t\treturn new Layout.ForceDirected.Spring(existingSpring.point1, existingSpring.point2, 0.0, 0.0);\n\t\t}\n\n\t\tvar to = this.graph.getEdges(edge.target, edge.source);\n\t\tfrom.forEach(function(e){\n\t\t\tif (existingSpring === false && typeof(this.edgeSprings[e.id]) !== 'undefined') {\n\t\t\t\texistingSpring = this.edgeSprings[e.id];\n\t\t\t}\n\t\t}, this);\n\n\t\tif (existingSpring !== false) {\n\t\t\treturn new Layout.ForceDirected.Spring(existingSpring.point2, existingSpring.point1, 0.0, 0.0);\n\t\t}\n\n\t\tthis.edgeSprings[edge.id] = new Layout.ForceDirected.Spring(\n\t\t\tthis.point(edge.source), this.point(edge.target), length, this.stiffness\n\t\t);\n\t}\n\n\treturn this.edgeSprings[edge.id];\n};\n\n// callback should accept two arguments: Node, Point\nLayout.ForceDirected.prototype.eachNode = function(callback) {\n\tvar t = this;\n\tthis.graph.nodes.forEach(function(n){\n\t\tcallback.call(t, n, t.point(n));\n\t});\n};\n\n// callback should accept two arguments: Edge, Spring\nLayout.ForceDirected.prototype.eachEdge = function(callback) {\n\tvar t = this;\n\tthis.graph.edges.forEach(function(e){\n\t\tcallback.call(t, e, t.spring(e));\n\t});\n};\n\n// callback should accept one argument: Spring\nLayout.ForceDirected.prototype.eachSpring = function(callback) {\n\tvar t = this;\n\tthis.graph.edges.forEach(function(e){\n\t\tcallback.call(t, t.spring(e));\n\t});\n};\n\n\n// Physics stuff\nLayout.ForceDirected.prototype.applyCoulombsLaw = function() {\n\tthis.eachNode(function(n1, point1) {\n\t\tthis.eachNode(function(n2, point2) {\n\t\t\tif (point1 !== point2)\n\t\t\t{\n\t\t\t\tvar d = point1.p.subtract(point2.p);\n\t\t\t\tvar distance = d.magnitude() + 0.1; // avoid massive forces at small distances (and divide by zero)\n\t\t\t\tvar direction = d.normalise();\n\n\t\t\t\t// apply force to each end point\n\t\t\t\tpoint1.applyForce(direction.multiply(this.repulsion).divide(distance * distance * 0.5));\n\t\t\t\tpoint2.applyForce(direction.multiply(this.repulsion).divide(distance * distance * -0.5));\n\t\t\t}\n\t\t});\n\t});\n};\n\nLayout.ForceDirected.prototype.applyHookesLaw = function() {\n\tthis.eachSpring(function(spring){\n\t\tvar d = spring.point2.p.subtract(spring.point1.p); // the direction of the spring\n\t\tvar displacement = spring.length - d.magnitude();\n\t\tvar direction = d.normalise();\n\n\t\t// apply force to each end point\n\t\tspring.point1.applyForce(direction.multiply(spring.k * displacement * -0.5));\n\t\tspring.point2.applyForce(direction.multiply(spring.k * displacement * 0.5));\n\t});\n};\n\nLayout.ForceDirected.prototype.attractToCentre = function() {\n\tthis.eachNode(function(node, point) {\n\t\tvar direction = point.p.multiply(-1.0);\n\t\tpoint.applyForce(direction.multiply(this.repulsion / 50.0));\n\t});\n};\n\n\nLayout.ForceDirected.prototype.updateVelocity = function(timestep) {\n\tthis.eachNode(function(node, point) {\n\t\t// Is this, along with updatePosition below, the only places that your\n\t\t// integration code exist?\n\t\tpoint.v = point.v.add(point.a.multiply(timestep)).multiply(this.damping);\n\t\tpoint.a = new Vector(0,0);\n\t});\n};\n\nLayout.ForceDirected.prototype.updatePosition = function(timestep) {\n\tthis.eachNode(function(node, point) {\n\t\t// Same question as above; along with updateVelocity, is this all of\n\t\t// your integration code?\n\t\tpoint.p = point.p.add(point.v.multiply(timestep));\n\t});\n};\n\n// Calculate the total kinetic energy of the system\nLayout.ForceDirected.prototype.totalEnergy = function(timestep) {\n\tvar energy = 0.0;\n\tthis.eachNode(function(node, point) {\n\t\tvar speed = point.v.magnitude();\n\t\tenergy += 0.5 * point.m * speed * speed;\n\t});\n\n\treturn energy;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; }; // stolen from coffeescript, thanks jashkenas! ;-)\n\nLayout.requestAnimationFrame = __bind(window.requestAnimationFrame ||\n\twindow.webkitRequestAnimationFrame ||\n\twindow.mozRequestAnimationFrame ||\n\twindow.oRequestAnimationFrame ||\n\twindow.msRequestAnimationFrame ||\n\tfunction(callback, element) {\n\t\twindow.setTimeout(callback, 10);\n\t}, window);\n\n\n// start simulation\nLayout.ForceDirected.prototype.start = function(interval, render, done) {\n\tvar t = this;\n\n\tif (this._started) return;\n\tthis._started = true;\n\n\tLayout.requestAnimationFrame(function step() {\n\t\tt.applyCoulombsLaw();\n\t\tt.applyHookesLaw();\n\t\tt.attractToCentre();\n\t\tt.updateVelocity(0.03);\n\t\tt.updatePosition(0.03);\n\n\t\tif (typeof(render) !== 'undefined')\n\t\t\trender();\n\n\t\t// stop simulation when energy of the system goes below a threshold\n\t\tif (t.totalEnergy() < 0.01) {\n\t\t\tt._started = false;\n\t\t\tif (typeof(done) !== 'undefined') { done(); }\n\t\t} else {\n            \n            Layout.requestAnimationFrame(step);\n\n\t\t}\n\t});\n};\n\n// Find the nearest point to a particular position\nLayout.ForceDirected.prototype.nearest = function (pos) {\n\n    var min = { node: null, point: null, distance: 1 };\n    var t = this;\n    this.graph.nodes.forEach(function (n) {\n        var point = t.point(n);\n        var distance = point.p.subtract(pos).magnitude();\n\n        if (min.distance === null || distance < min.distance) {\n            min = { node: n, point: point, distance: distance };\n        }\n    });\n\n  \n\n    return min;\n};\n\n// returns [bottomleft, topright]\nLayout.ForceDirected.prototype.getBoundingBox = function() {\n\tvar bottomleft = new Vector(-2,-2);\n\tvar topright = new Vector(2,2);\n\n\tthis.eachNode(function(n, point) {\n\t\tif (point.p.x < bottomleft.x) {\n\t\t\tbottomleft.x = point.p.x;\n\t\t}\n\t\tif (point.p.y < bottomleft.y) {\n\t\t\tbottomleft.y = point.p.y;\n\t\t}\n\t\tif (point.p.x > topright.x) {\n\t\t\ttopright.x = point.p.x;\n\t\t}\n\t\tif (point.p.y > topright.y) {\n\t\t\ttopright.y = point.p.y;\n\t\t}\n\t});\n\n\tvar padding = topright.subtract(bottomleft).multiply(0.07); // ~5% padding\n\n\treturn {bottomleft: bottomleft.subtract(padding), topright: topright.add(padding)};\n};\n\n\n\n\n// Vector\nVector = function(x, y) {\n\tthis.x = x;\n\tthis.y = y;\n};\n\nVector.random = function() {\n\treturn new Vector(10.0 * (Math.random() - 0.5), 10.0 * (Math.random() - 0.5));\n};\n\nVector.prototype.add = function(v2) {\n\treturn new Vector(this.x + v2.x, this.y + v2.y);\n};\n\nVector.prototype.subtract = function(v2) {\n\treturn new Vector(this.x - v2.x, this.y - v2.y);\n};\n\nVector.prototype.multiply = function(n) {\n\treturn new Vector(this.x * n, this.y * n);\n};\n\nVector.prototype.divide = function(n) {\n\treturn new Vector((this.x / n) || 0, (this.y / n) || 0); // Avoid divide by zero errors..\n};\n\nVector.prototype.magnitude = function() {\n\treturn Math.sqrt(this.x*this.x + this.y*this.y);\n};\n\nVector.prototype.normal = function() {\n\treturn new Vector(-this.y, this.x);\n};\n\nVector.prototype.normalise = function() {\n\treturn this.divide(this.magnitude());\n};\n\n\n\n\n\n\n\n// Point\nLayout.ForceDirected.Point = function(position, mass) {\n\tthis.p = position; // position\n\tthis.m = mass; // mass\n\tthis.v = new Vector(0, 0); // velocity\n\tthis.a = new Vector(0, 0); // acceleration\n};\n\nLayout.ForceDirected.Point.prototype.applyForce = function(force) {\n\tthis.a = this.a.add(force.divide(this.m));\n};\n\n// Spring\nLayout.ForceDirected.Spring = function(point1, point2, length, k) {\n\tthis.point1 = point1;\n\tthis.point2 = point2;\n\tthis.length = length; // spring length at rest\n\tthis.k = k; // spring constant (See Hooke's law) .. how stiff the spring is\n};\n\n\n\n\n\n\n\n\n\n// Layout.ForceDirected.Spring.prototype.distanceToPoint = function(point)\n// {\n// \t// hardcore vector arithmetic.. ohh yeah!\n// \t// .. see http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment/865080#865080\n// \tvar n = this.point2.p.subtract(this.point1.p).normalise().normal();\n// \tvar ac = point.p.subtract(this.point1.p);\n// \treturn Math.abs(ac.x * n.x + ac.y * n.y);\n// };\n\n// Renderer handles the layout rendering loop\nfunction Renderer(interval, layout, clear, drawEdge, drawNode) {\n\tthis.interval = interval;\n\tthis.layout = layout;\n\tthis.clear = clear;\n\tthis.drawEdge = drawEdge;\n\tthis.drawNode = drawNode;\n\n\tthis.layout.graph.addGraphListener(this);\n}\n\nRenderer.prototype.graphChanged = function(e) {\n\tthis.start();\n};\n\nRenderer.prototype.start = function() {\n\tvar t = this;\n\tthis.layout.start(1, function render() {\n\t\tt.clear();\n\n\t\tt.layout.eachEdge(function(edge, spring) {\n\t\t\tt.drawEdge(edge, spring.point1.p, spring.point2.p);\n\t\t});\n\n\t\tt.layout.eachNode(function(node, point) {\n\t\t\tt.drawNode(node, point.p);\n\t\t});\n\t});\n};\n\n"]],"start1":0,"start2":0,"length1":0,"length2":16208}]],"length":16208}
{"contributors":[],"silentsave":false,"ts":1360762274256,"patch":[[{"diffs":[[0,"});\n};\n\n"],[-1,"\n"],[0,"// Physi"]],"start1":9285,"start2":9285,"length1":17,"length2":16},{"diffs":[[0,"\n};\n\n\n\n\n"],[-1,"\n\n\n\n\n\n\n\n\n\n"],[0,"var __bi"]],"start1":11459,"start2":11459,"length1":26,"length2":16},{"diffs":[[0,"\n\n\n\n"],[-1,"\n\n\n// Layout.ForceDirected.Spring.prototype.distanceToPoint = function(point)\n// {\n// \t// hardcore vector arithmetic.. ohh yeah!\n// \t// .. see http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment/865080#865080\n// \tvar n = this.point2.p.subtract(this.point1.p).normalise().normal();\n// \tvar ac = point.p.subtract(this.point1.p);\n// \treturn Math.abs(ac.x * n.x + ac.y * n.y);\n// };\n\n// Renderer handles the layout rendering loop\nfunction Renderer(interval, layout, clear, drawEdge, drawNode) {\n\tthis.interval = interval;\n\tthis.layout = layout;\n\tthis.clear = clear;\n\tthis.drawEdge = drawEdge;\n\tthis.drawNode = drawNode;\n\n\tthis.layout.graph.addGraphListener(this);\n}\n\nRenderer.prototype.graphChanged = function(e) {\n\tthis.start();\n};\n\nRenderer.prototype.start = function() {\n\tvar t = this;\n\tthis.layout.start(1, function render() {\n\t\tt.clear();\n\n\t\tt.layout.eachEdge(function(edge, spring) {\n\t\t\tt.drawEdge(edge, spring.point1.p, spring.point2.p);\n\t\t});\n\n\t\tt.layout.eachNode(function(node, point) {\n\t\t\tt.drawNode(node, point.p);\n\t\t});\n\t});\n};"],[1,"    var mapHandler = function(currentBB, graph){\n        \n        //this.graph =graph;\n        this.currentBB = currentBB;\n        \n        // graph size \n        this.graph_width = 2000;\n        this.graph_height = 2000;\n\n        //display size\n        this.display_width = window.innerWidth + 500;\n        this.display_height = window.innerHeight + 500;\n\n        //save screen width/height\n        this.screenHeight = screen.height;\n        this.screenWidth = screen.width;\n\n        //positional controls\n        this.centrePoint = 0;\n        this.centreVerticalPoint = 0;\n        this.zoomOffset = 0;\n\n        this.centrePointXOffset = 0.0;\n        this.centrePointYOffset = 0.0;\n\n        this.mouse_x = 0;\n        this.mouse_y = 0;\n\n        // queue of points to move graph to \n        this.mouseQueue = [];\n\n        this.mouseXPercLocat = 0.0;\n        this.mouseYPercLocat = 0.0;\n\n        this.percX1 = 0.0;\n        this.percY1 = 0.0; \n\n    }\n\n\n    mapHandler.prototype = {\n        \n        SetCentrePoint:function (param_x, param_y) {\n            if (param_x == 1000000 && param_y == 1000000) {\n                this.centrePointXOffset = 0;\n                this.centrePointYOffset = 0;\n            }\n            else {\n                if (this.centrePointXOffset === 0) {\n                    this.centrePointXOffset = this.centrePoint - param_x;\n                }\n                else {\n\n                    this.centrePoint = param_x + this.centrePointXOffset;\n                }\n                if (this.centrePointYOffset === 0) {\n                    this.centrePointYOffset = this.centreVerticalPoint - param_y;\n                }\n                else {\n\n                    this.centreVerticalPoint = param_y + this.centrePointYOffset;\n                }\n            }\n        },\n        SetZoomStart: function () {\n            this.GetPercDistances();\n            this.mouseXPercLocat = this.percX1;\n            this.mouseYPercLocat = this.percY1;\n        },\n        GetPercDistances: function () {\n\n\n            var _distanceFromX1 = 0.0;\n            var _distanceFromY1 = 0.0;\n            var _onePercentDistance = 0.0;\n\n            this.percX1 = 0.0;\n            this.percY1 = 0.0;\n\n\n\n            //   this.drawingWidth = this.drawingX2 - this.drawingX1;\n            //  this.drawingHeight = this.drawingY2 - this.drawingY1;\n\n\n\n            if (this.graph_width !== 0 && this.graph_height !== 0) {\n                if (this.centrePoint > 0) {\n                    _distanceFromX1 = this.mouse_x - this.centrePoint; //;\n                }\n                else {\n                    _distanceFromX1 = Math.abs(this.centrePoint) + this.mouse_x;\n                }\n\n                _onePercentDistance = this.graph_width / 100;\n                this.percX1 = _distanceFromX1 / _onePercentDistance;\n\n                if (this.centreVerticalPoint > 0) {\n                    _distanceFromY1 = this.mouse_y - this.centreVerticalPoint; // ;                \n                }\n                else {\n                    _distanceFromY1 = Math.abs(this.centreVerticalPoint) + this.mouse_y;\n                }\n\n                _onePercentDistance = this.graph_height / 100;\n                this.percY1 = _distanceFromY1 / _onePercentDistance;\n\n            }\n\n\n        },\n        UpdatePosition:function(_dir){\n            \n            var increment = 2;\n            \n            if (_dir == 'SOUTH') {\n                this.centreVerticalPoint -= increment;\n            }\n            if (_dir == 'NORTH') {\n                this.centreVerticalPoint += increment;\n            }\n            if (_dir == 'EAST') {\n                this.centrePoint += increment;\n            }\n            if (_dir == 'WEST') {\n\n                this.centrePoint -= increment;\n            }\n            if (_dir == 'UP' || _dir == 'DOWN') {\n\n                this.mouse_x = this.screenWidth / 2;\n                this.mouse_y = this.screenHeight / 2;\n\n                this.GetPercDistances();\n\n                this.mouseXPercLocat = this.percX1;\n                this.mouseYPercLocat = this.percY1;\n\n                // zero the centre point \n                this.SetCentrePoint(1000000, 1000000);\n\n                if (_dir == 'UP') {\n                    this.graph_width += 50;\n                    this.graph_height += 50;\n                } else {\n                    this.graph_width -= 50;\n                    this.graph_height -= 50;\n                }\n\n                this.GetPercDistances();\n\n\n                //console.log('y zoom ' + percY1 + ' ' + mouseYPercLocat);\n                this.centreVerticalPoint += (this.graph_height / 100) * (this.percY1 - this.mouseYPercLocat);\n                //console.log('x zoom ' + percX1 + ' ' + mouseXPercLocat);\n\n                this.centrePoint += (this.graph_width / 100) * (this.percX1 - this.mouseXPercLocat);\n            }\n\n        },\n        \n       \n        \n        currentPositionFromScreen:function(pos,e){\n            \n             var utils = new Utils();\n            \n            \n            \n             var p = utils.fromScreen({ x: (e.pageX - this.centrePoint) - pos.left, y: (e.pageY - this.centreVerticalPoint) - pos.top });            \n             return p;\n        },\n        currentPositionToScreen:function(pos,e){\n             var utils = new Utils();\n             \n             var p = utils.toScreen({ x: (e.pageX - this.centrePoint) - pos.left, y: (e.pageY - this.centreVerticalPoint) - pos.top });            \n             return p;\n        },\n        \n        addToMouseQueue: function(x,y){            \n            var _point = new Array(x, y);\n            this.mouseQueue[this.mouseQueue.length] = _point;            \n        }\n       \n\n        \n \n\n    };\n\n\n\n\n// Layout.ForceDirected.Spring.prototype.distanceToPoint = function(point)\n// {\n// \t// hardcore vector arithmetic.. ohh yeah!\n// \t// .. see http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment/865080#865080\n// \tvar n = this.point2.p.subtract(this.point1.p).normalise().normal();\n// \tvar ac = point.p.subtract(this.point1.p);\n// \treturn Math.abs(ac.x * n.x + ac.y * n.y);\n// };\n\n// Renderer handles the layout rendering loop\nfunction Renderer(interval, layout, clear, drawEdge, drawNode) {\n\tthis.interval = interval;\n\tthis.layout = layout;\n\tthis.clear = clear;\n\tthis.drawEdge = drawEdge;\n\tthis.drawNode = drawNode;\n\n\tthis.layout.graph.addGraphListener(this);\n}\n\nRenderer.prototype.graphChanged = function(e) {\n\tthis.start();\n};\n\nRenderer.prototype.start = function() {\n\tvar t = this;\n\tthis.layout.start(1, function render() {\n\t\tt.clear();\n\n\t\tt.layout.eachEdge(function(edge, spring) {\n\t\t\tt.drawEdge(edge, spring.point1.p, spring.point2.p);\n\t\t});\n\n\t\tt.layout.eachNode(function(node, point) {\n\t\t\tt.drawNode(node, point.p);\n\t\t});\n\t});\n};\n\n\nfunction Utils(currentBB){\n    this.currentBB = currentBB;    \n}\n\nUtils.prototype = {\n    \n        toScreen:function (p) {\n            var size = this.currentBB.topright.subtract(this.currentBB.bottomleft);\n            var sx = p.subtract(this.currentBB.bottomleft).divide(size.x).x * this.graph_width;\n            var sy = p.subtract(this.currentBB.bottomleft).divide(size.y).y * this.graph_height;\n            return new Vector(sx, sy);\n        },\n\n        fromScreen:function (s) {\n            var size = this.currentBB.topright.subtract(this.currentBB.bottomleft);\n            var px = (s.x / this.graph_width) * size.x + this.currentBB.bottomleft.x;\n            var py = (s.y / this.graph_height) * size.y + this.currentBB.bottomleft.y;\n            return new Vector(px, py);\n        },\n        intersect_line_line: function(p1, p2, p3, p4) {\n            var denom = ((p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y));\n\n            // lines are parallel\n            if (denom === 0) {\n                return false;\n            }\n\n            var ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denom;\n            var ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denom;\n\n            if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {\n                return false;\n            }\n\n            return new Vector(p1.x + ua * (p2.x - p1.x), p1.y + ua * (p2.y - p1.y));\n        },\n\n        intersect_line_box: function(p1, p2, p3, w, h) {\n            var tl = { x: p3.x, y: p3.y };\n            var tr = { x: p3.x + w, y: p3.y };\n            var bl = { x: p3.x, y: p3.y + h };\n            var br = { x: p3.x + w, y: p3.y + h };\n\n            var result;\n            if (result = this.intersect_line_line(p1, p2, tl, tr)) { return result; } // top\n            if (result = this.intersect_line_line(p1, p2, tr, br)) { return result; } // right\n            if (result = this.intersect_line_line(p1, p2, br, bl)) { return result; } // bottom\n            if (result = this.intersect_line_line(p1, p2, bl, tl)) { return result; } // left\n\n            return false;\n        }\n    \n}\n\n\n\n\n"],[0,"\n\n"]],"start1":15113,"start2":15113,"length1":1084,"length2":8917}]],"length":24030,"saved":false}
{"ts":1360762355107,"patch":[[{"diffs":[[0,"function(pos,e){"],[-1,"\n"],[0,"            \n   "]],"start1":20026,"start2":20026,"length1":33,"length2":32},{"diffs":[[0,"ils("],[-1,");\n            \n            \n"],[1,"this.currentBB);    "],[0,"    "]],"start1":20086,"start2":20086,"length1":37,"length2":28},{"diffs":[[0,"w Utils("],[1,"this.currentBB"],[0,");"],[-1,"\n"],[0,"        "]],"start1":20383,"start2":20383,"length1":19,"length2":32}]],"length":24033,"saved":false}
{"ts":1360762583240,"patch":[[{"diffs":[[0,"awNode;\n"],[1,"    this.mapHandler = mapHandler;\n    "],[0,"\n\tthis.l"]],"start1":21470,"start2":21470,"length1":16,"length2":54}]],"length":24071,"saved":false}
{"ts":1360762600478,"patch":[[{"diffs":[[0,"nterval,"],[1,"mapHandler,"],[0," layout,"]],"start1":21307,"start2":21307,"length1":16,"length2":27}]],"length":24082,"saved":false}
{"ts":1360763654891,"patch":[[{"diffs":[[0,"      \n        }"],[1,","],[0,"\n       \n\n      "]],"start1":20773,"start2":20773,"length1":32,"length2":33},{"diffs":[[0,"       \n"],[1,"        validToDraw:function(x1,y1){\n            \n            var validDraw =true;\n            \n            if ( x1 > this.display_width) validDraw = false;\n    \t    if ( x1 < -500) validDraw = false;\n            if ( y1 > this.display_height) validDraw = false;\n            if ( y1 < -500) validDraw = false;\n            \n            return validDraw;    \n        }"],[0,"\n       "]],"start1":20791,"start2":20791,"length1":16,"length2":382}]],"length":24449,"saved":false}
{"ts":1360764046869,"patch":[[{"diffs":[[0,"w;    \n        }"],[1,","],[0,"\n        \n \n\n   "]],"start1":21149,"start2":21149,"length1":32,"length2":33},{"diffs":[[0,"        "],[1,"mapOffset:function(v1){\n            \n            v1.x += this.centrePoint;\n\t\t    v1.y += this.centreVerticalPoint;\n            \n            return v1;\n        }"],[0,"\n \n\n    "]],"start1":21167,"start2":21167,"length1":16,"length2":176}]],"length":24610,"saved":false}
